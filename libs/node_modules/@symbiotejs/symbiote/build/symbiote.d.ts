export class Data {
	static warn(actionName: string, prop: string): void;
	static registerLocalCtx(schema: {
		[x: string]: any;
	}): Data;
	static registerNamedCtx(ctxName: string, schema: {
		[x: string]: any;
	}): Data;
	static clearNamedCtx(ctxName: string): void;
	static getNamedCtx(ctxName: string, notify?: boolean): Data;
	constructor(src: {
		name?: string;
		schema: {
			[x: string]: any;
		};
	});
	uid: symbol;
	name: string;
	store: {
		[x: string]: any;
	};
	_storeIsProxy: boolean;
	callbackMap: any;
	read(prop: string): any;
	has(prop: string): boolean;
	add(prop: string, val: any, rewrite?: boolean): void;
	pub(prop: string, val: any): void;
	multiPub(updObj: {
		[x: string]: any;
	}): void;
	notify(prop: string): void;
	sub(prop: string, callback: Function, init?: boolean): {
		remove: () => void;
		callback: Function;
	};
	remove(): void;
}
export namespace Data {
	const globalStore: any;
}
export class BaseComponent extends HTMLElement {
	static __parseProp(prop: string, fnCtx: any): {
		ctx: Data;
		name: string;
	};
	static reg(tagName?: string, isAlias?: boolean): void;
	static get is(): string;
	static bindAttributes(desc: {
		[x: string]: string;
	}): void;
	static set shadowStyles(arg: string);
	initCallback(): void;
	__initCallback(): void;
	__initialized: boolean;
	render(template?: string | DocumentFragment, shadow?: boolean): void;
	addTemplateProcessor(processorFn: (fr: DocumentFragment, fnCtx: any) => any): void;
	init$: {
		[x: string]: any;
	};
	tplProcessors: Set<(fr: DocumentFragment, fnCtx: any) => any>;
	ref: {
		[x: string]: HTMLElement;
	};
	allSubs: Set<any>;
	pauseRender: boolean;
	renderShadow: boolean;
	readyToDestroy: boolean;
	get autoCtxName(): string;
	__autoCtxName: string;
	get cssCtxName(): any;
	get ctxName(): any;
	get localCtx(): Data;
	__localCtx: Data;
	get nodeCtx(): Data;
	sub(prop: string, handler: (value: any) => void): void;
	notify(prop: string): void;
	has(prop: string): boolean;
	add(prop: string, val: any): void;
	add$(obj: {
		[x: string]: any;
	}): void;
	get $(): {
		[x: string]: any;
	};
	__stateProxy: {
		[x: string]: any;
	};
	set$(kvObj: {
		[x: string]: any;
	}): void;
	__initDataCtx(): void;
	__dataCtxInitialized: boolean;
	connectedCallback(): void;
	__initChildren: ChildNode[];
	connectedOnce: boolean;
	destroyCallback(): void;
	disconnectedCallback(): void;
	__disconnectTimeout: number;
	attributeChangedCallback(name: any, oldVal: any, newVal: any): void;
	getCssData(propName: string, silentCheck?: boolean): any;
	__cssDataCache: any;
	__computedStyle: CSSStyleDeclaration;
	bindCssData(propName: string, external?: boolean): string;
	dropCssDataCache(): void;
	defineAccessor(propName: string, handler?: Function, isAsync?: boolean): void;
}
export class TypedData {
	constructor(typedSchema: {
		[x: string]: {
			type: any;
			value: any;
		};
	}, ctxName?: string);
	__typedSchema: {
		[x: string]: {
			type: any;
			value: any;
		};
	};
	__ctxId: string;
	__schema: {};
	__state: Data;
	setValue(prop: string, value: any): void;
	setMultipleValues(updObj: {
		[x: string]: any;
	}): void;
	getValue(prop: string): any;
	subscribe(prop: string, handler: (newVal: any) => void): {
		remove: () => void;
		callback: Function;
	};
	remove(): void;
}
export class TypedCollection {
	constructor(options: {
		typedSchema: {
			[x: string]: {
				type: any;
				value: any;
			};
		};
		watchList?: string[];
		handler?: (list: string[]) => void;
		ctxName?: string;
	});
	__typedSchema: {
		[x: string]: {
			type: any;
			value: any;
		};
	};
	__ctxId: string;
	__state: Data;
	__watchList: string[];
	__handler: (list: string[]) => void;
	__subsMap: any;
	__observers: Set<any>;
	__items: Set<string>;
	__notifyObservers: (propName: any, ctxId: any) => void;
	__observeTimeout: number;
	notify(): void;
	__notifyTimeout: number;
	add(init: any): TypedData;
	read(id: string): TypedData;
	readProp(id: any, propName: any): any;
	publishProp(id: any, propName: any, value: any): void;
	remove(id: any): void;
	clearAll(): void;
	observe(handler: Function): void;
	unobserve(handler: Function): void;
	findItems(checkFn: (item: TypedData) => boolean): string[];
	items(): string[];
	destroy(): void;
}
export class AppRouter {
	static _print(msg: any): void;
	static setDefaultTitle(title: string): void;
	static setRoutingMap(map: {
		[x: string]: {};
	}): void;
	static set routingEventName(arg: any);
	static get routingEventName(): any;
	static readAddressBar(): {
		route: any;
		options: {};
	};
	static notify(): void;
	static reflect(route: string, options?: {
		[x: string]: any;
	}): void;
	static applyRoute(route: string, options?: {
		[x: string]: any;
	}): void;
	static setSeparator(char: string): void;
	static get separator(): string;
	static createRouterData(ctxName: string, routingMap: {
		[x: string]: {};
	}): Data;
}
export namespace AppRouter {
	const defaultTitle: string;
	const defaultRoute: string;
	const errorRoute: string;
	const __routingEventName: any;
	const _separator: string;
	const appMap: any;
}
export class UID {
	static generate(pattern?: string): string;
}
export class IDB {
	static get readyEventName(): string;
	static open(dbName?: string, storeName?: string): DbInstance;
	static clear(dbName: string): void;
}
export namespace IDB {
	const _reg: any;
}
declare class DbInstance {
	constructor(dbName: string, storeName: string);
	_notifyWhenReady(event?: any): void;
	get _updEventName(): string;
	_getUpdateEvent(key: any): CustomEvent<{
		key: string;
		newValue: any;
	}>;
	_notifySubscribers(key: any): void;
	name: string;
	storeName: string;
	version: number;
	request: IDBOpenDBRequest;
	db: any;
	objStore: any;
	_subscribtionsMap: {};
	_updateHandler: (e: StorageEvent) => void;
	_localUpdateHandler: (e: any) => void;
	read(key: string): Promise<any>;
	write(key: string, value: any, silent?: boolean): Promise<any>;
	delete(key: string, silent?: boolean): Promise<any>;
	getAll(): Promise<any>;
	subscribe(key: string, callback: Function): {
		remove: () => void;
	};
	stop(): void;
	__subscribtionsMap: any;
}
export function applyStyles(el: any, styleMap: StyleMap): void;
export function applyAttributes(el: any, attrMap: AttrMap): void;
export function create(desc?: ElementDescriptor): HTMLElement;
export type StyleMap = {
	[x: string]: string | number;
};
export type AttrMap = {
	[x: string]: string | number | boolean;
};
export type PropMap = {
	[x: string]: any;
};
export type ElementDescriptor = {
	tag?: string;
	attributes?: AttrMap;
	styles?: StyleMap;
	properties?: PropMap;
	processors?: Function[];
	children?: ElementDescriptor[];
};

export {};
